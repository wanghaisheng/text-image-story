
<html><head><base href="." /><title>BAREBONES ENGINE</title>
<meta charset="utf-8" />
<style>
@font-face {
    font-family: 'DTM-Sans';
    src: url('DTM-Sans.otf') format('opentype');
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    background: black;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    font-family: 'DTM-Sans', "Courier New", monospace; 
    color: white;
}

.container {
    text-align: center;
    border: 4px solid white;
    padding: 40px;
    position: relative;
    width: 90%;
    max-width: 600px;
    transition: background-color 2s;
    overflow: hidden;
}

.container.fade-white {
    background-color: white;
}

#nameTitle {
    font-size: 28px;  
    margin-bottom: 20px;
}

.name-display {
    font-size: 36px;  
    margin: 20px 0;
    min-height: 44px;  
    transition: all 1s ease-in-out;
}

.name-display.confirmed {
    transform: scale(2);
    margin: 60px 0;
}

.name-display.final {
    transform: scale(3);
}

.letter {
    display: inline-block;
    font-size: 36px;  
    margin: 0 3px;  
    cursor: pointer;
}

.shake {
    animation: shake 1.5s infinite steps(4);
    animation-delay: var(--delay);
}

@keyframes shake {
    0% { transform: translate(0, 0); }
    25% { transform: translate(-3px, -2px); }
    50% { transform: translate(2px, 3px); }
    75% { transform: translate(-2px, 1px); }
    100% { transform: translate(0, 0); }
}

.controls {
    margin-top: 20px;
    transition: opacity 1s;
}

.controls.hidden {
    opacity: 0;
    pointer-events: none;
}

.button {
    display: inline-block;
    padding: 10px 20px;
    margin: 0 10px;
    border: 2px solid white;
    cursor: pointer;
    transition: all 0.3s;
}

.button:hover {
    background: white;
    color: black;
}

.letter-grid {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 10px;
    max-width: 400px;
    margin: 0 auto;
    transition: opacity 0.5s ease-out;
}

.letter-grid.hidden {
    opacity: 0;
    pointer-events: none;
}

#gameWorld {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    transition: opacity 2s;
    background: #000;
    display: none;
}

#gameWorld.visible {
    opacity: 1;
    display: block;
}

#player {
    position: absolute;
    width: 32px;
    height: 48px;
    transition: transform 0.1s linear, opacity 0.4s ease;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    background-image: url('Down.png');
    z-index: 10;
    image-rendering: pixelated;
    will-change: transform, background-image, opacity;
}

#player.in-battle {
    opacity: 0;
}

/* Battle Transition Effects */
.battle-flash {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: white;
    opacity: 0;
    pointer-events: none;
    z-index: 2;
}

.battle-flash.active {
    animation: flash 0.8s steps(4);
}

@keyframes flash {
    0% { opacity: 0; }
    50% { opacity: 1; }
    100% { opacity: 0; }
}

/* Battle Interface */
.battle-interface {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    display: none;
    z-index: 3;
}

.battle-menu {
    display: flex;
    justify-content: space-around;
    margin-top: 10px;
}

.battle-option {
    color: white;
    font-size: 24px;  
    cursor: pointer;
    padding: 5px 12px;  
    transition: all 0.3s;
}

.battle-option:hover {
    color: yellow;
}

.battle-option.selected {
    color: yellow;
    transform: scale(1.1);
}

.battle-option:not(.selected) {
    opacity: 0.8;
}

/* Battle Text Box */
.battle-text-box {
    position: absolute;
    bottom: 120px; /* Adjust this value to position above stats */
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    background: black;
    border: 4px solid white;
    padding: 15px;
    font-size: 20px;  
    display: none;
    z-index: 3;
    min-height: 100px; 
}

/* Update combat mode text box/battle box positioning */
.battle-text-box.combat-mode,
.battle-box {
    position: absolute;
    top: 120px; /* Match the regular text box position */
    left: 50%;
    transform: translateX(-50%);
    width: 200px;
    height: 200px;
    min-height: 200px;
}

/* Ensure battle stats stay below */
.battle-stats {
    position: absolute;
    bottom: 60px; 
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    color: white;
    font-size: 20px;  
    display: none;
    z-index: 3;
}

.stats-row {
    display: flex;
    align-items: center;
    margin-bottom: 5px;
}

.name-stats {
    margin-right: 20px;
}

.hp-label {
    margin-right: 10px;
}

.hp-bar-container {
    width: 100px; 
    height: 20px;
    background: red;
    position: relative;
}

.hp-bar {
    height: 100%;
    background: yellow;
    transition: width 0.3s;
}

.hp-numbers {
    margin-left: 10px;
}

.battle-box {
    position: absolute;
    left: 50%;
    top: -370%;
    transform: translate(-50%, -50%);
    width: 200px;
    height: 200px;
    border: 4px solid white;
    display: none;
    z-index: 4;
}

.player-soul {
    position: absolute;
    width: 16px;
    height: 16px;
    background-image: url('Soul.png');
    background-size: contain;
    background-repeat: no-repeat;
    z-index: 5;
    transition: transform 0.1s linear;
    image-rendering: pixelated;
    will-change: transform, opacity; /* Add opacity to will-change */
}

.battle-text-box.combat-mode {
    bottom: auto;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 200px;
    height: 200px;
    min-height: 200px;
}

.intro-sequence {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: black;
    z-index: 100;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    opacity: 1;
}

.intro-sequence.hidden {
    display: none;  /* Change from opacity transition to display none */
}

.intro-image {
    width: 320px;
    height: 240px;
    background: transparent;  /* Changed from #fff to transparent */
    margin: 20px 0;
    display: none; /* Start hidden */
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
}

.intro-text {
    color: white;
    font-size: 24px;
    text-align: center;
    margin: 20px 0;
    opacity: 1;
    white-space: pre-line;
}

/* Remove these classes as we'll no longer use them */
.intro-image.visible,
.intro-text.visible {
    display: block; /* For intro-image */
}

.credits-sequence {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: black;
    z-index: 99;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    opacity: 1;
    transition: opacity 2s;
}

.credits-sequence.hidden {
    opacity: 0;
    pointer-events: none;
}

.title-text {
    color: white;
    font-size: 48px;
    text-align: center;
    margin-bottom: 20px;
}

.subtitle-text {
    color: white;
    font-size: 24px;
    text-align: center;
    margin-bottom: 40px;
}

.credits-text {
    color: white;
    font-size: 16px;
    text-align: center;
    margin: 10px 0;
}

.credits-text a {
    color: #00a8ff;
    text-decoration: none;
}

.credits-text a:hover {
    text-decoration: underline;
}

/* Add new styles for the attack bar */
.attack-bar-container {
    position: absolute;
    top: 50%;
    left: 0;
    width: 100%;
    height: 40px;
    display: none;
    transform: translateY(-50%);
    z-index: 6;
}

.attack-bar {
    position: absolute;
    left: 0;
    width: 8px;
    height: 100%;
    background: white;
    animation: moveAttackBar 2s linear;
}

.attack-target {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    width: 4px;
    height: 100%;
    background: rgba(255, 255, 255, 0.3);
}

@keyframes moveAttackBar {
    0% { left: 0; }
    100% { left: 100%; }
}

.enemy-sprite {
    position: absolute;
    top: -400px;  /* Changed from bottom positioning */
    left: 50%;
    transform: translateX(-50%);
    width: 192px;  /* Tripled from 64px */
    height: 192px;  /* Tripled from 64px */
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    image-rendering: pixelated;
    transition: transform 0.1s, top 0.5s ease;  /* Added top transition */
}

@keyframes damageShake {
    0% { transform: translate(-50%, 0); }
    25% { transform: translate(calc(-50% - var(--shake-intensity)), var(--shake-intensity)); }
    50% { transform: translate(calc(-50% + var(--shake-intensity)), calc(var(--shake-intensity) * -1)); }
    75% { transform: translate(calc(-50% - var(--shake-intensity)), var(--shake-intensity)); }
    100% { transform: translate(-50%, 0); }
}

.enemy-sprite.shake {
    animation: damageShake 0.3s ease-in-out;
    --shake-intensity: 5px;  /* Default shake intensity */
}

.bullet {
    position: absolute;
    width: 8px;
    height: 8px;
    background-color: white;
    z-index: 5;
}

.battle-box {
    overflow: hidden;
}

@keyframes flash-soul {
    0% { opacity: 1; }
    50% { opacity: 0.3; }
    100% { opacity: 1; }
}

.surprise-sprite {
    position: absolute;
    width: 32px;
    height: 48px;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    background-image: url('Surprise.png');
    z-index: 11;  /* Keep z-index the same */
    image-rendering: pixelated;
    opacity: 0;
    transition: opacity 0.3s;
}

.surprise-sprite.visible {
    opacity: 1;
}

/* New CSS for enemy fade out */
@keyframes enemyFadeOut {
    0% { opacity: 1; }
    100% { opacity: 0; }
}

.enemy-sprite.fading {
    animation: enemyFadeOut 1s forwards;
}

.enemy-sprite.spared {
    opacity: 0.5;
    transition: opacity 0.5s;
}

/* Add these styles to the existing CSS */
.menu-interface {
    position: absolute;
    left: 20px;
    top: 50%;
    transform: translateY(-50%);
    background: black;
    border: 4px solid white;
    padding: 10px;
    display: none;
    z-index: 20;
}

.menu-option {
    color: white;
    font-size: 24px;
    padding: 5px 20px;
    cursor: pointer;
    transition: color 0.3s;
}

.menu-option.selected {
    color: yellow;
}
</style>
</head>
<body>
<div class="intro-sequence" id="introSequence">
    <div class="intro-image" id="introImage"></div>
    <div class="intro-text" id="introText"></div>
</div>

<div class="credits-sequence hidden" id="creditsSequence">
    <div class="title-text">BAREBONES</div>
    <div class="subtitle-text">A websim UT engine</div>
    <div class="credits-text">
        <a href="https://websim.ai/@TiaraNotBelle" target="_blank">@TiaraNotBelle</a> for attempting to put this thing together and making the sprites<br>
        (Not willing to steal from OG UT's sprites)
    </div>
    <div class="credits-text">
        Font from <a href="https://www.behance.net/gallery/31268855/Determination-Better-Undertale-Font" target="_blank">Determination (Better Undertale Font)</a>
    </div>
</div>

<div class="sprite-preloader"></div>

<div class="container" id="mainContainer">
    <div class="name-interface" id="nameInterface">
        <div id="nameTitle">Name the fallen human</div>
        <div class="name-display" id="selectedName"></div>
        <div class="letter-grid" id="letterGrid"></div>
        <div class="controls" id="controls">
            <span class="button" id="quitBtn">Quit</span>
            <span class="button" id="doneBtn">Done</span>
        </div>
    </div>
    <div id="gameWorld">
        <div id="player"></div>
        <div class="battle-flash"></div>
        <div class="battle-interface">
            <div class="battle-stats">
                <div class="stats-row">
                    <span class="name-stats"></span>
                    <span class="hp-label">HP</span>
                    <div class="hp-bar-container">
                        <div class="hp-bar"></div>
                    </div>
                    <span class="hp-numbers"></span>
                </div>
            </div>
            <div class="battle-text-box">
                <div class="battle-text"></div>
            </div>
            <div class="battle-menu">
                <div class="battle-option" data-option="FIGHT">FIGHT</div>
                <div class="battle-option" data-option="ACT">ACT</div>
                <div class="battle-option" data-option="ITEM">ITEM</div>
                <div class="battle-option" data-option="MERCY">MERCY</div>
            </div>
            <div class="battle-box">
                <div class="player-soul"></div>
            </div>
            <div class="enemy-sprite"></div>
        </div>
    </div>
</div>

<script>
class Bullet {
    constructor(x, y, type, params = {}) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.params = params;
        this.width = params.width || 8;  // Allow custom width
        this.height = params.height || 8;  // Allow custom height
        this.element = document.createElement('div');
        this.element.className = 'bullet';
        this.element.style.position = 'absolute';
        this.element.style.width = this.width + 'px';
        this.element.style.height = this.height + 'px';
        
        // Use custom sprite if provided, otherwise default white bullet
        if (params.sprite) {
            this.element.style.backgroundColor = 'transparent';
            this.element.style.backgroundImage = `url('${params.sprite}')`;
            this.element.style.backgroundSize = 'contain';
            this.element.style.backgroundRepeat = 'no-repeat';
            this.element.style.imageRendering = 'pixelated';
        } else {
            this.element.style.backgroundColor = 'white';
        }
        
        this.element.style.transform = `translate(${this.x}px, ${this.y}px)`;
    }

    update() {
        switch(this.type) {
            case 'hop':
                this.y += this.params.speed || 2;
                this.x += Math.sin(this.y / 30) * 2;
                break;
            case 'fly':
                this.x += this.params.speedX || 2;
                this.y += Math.sin(this.params.time * 0.1) * 2;
                this.params.time++;
                break;
            case 'spin':
                const angle = this.params.angle || 0;
                const radius = this.params.radius || 50;
                this.x = 100 + Math.cos(angle) * radius;
                this.y = 100 + Math.sin(angle) * radius;
                this.params.angle += 0.05;
                break;
            case 'dance':
                this.y += this.params.speed || 3;
                this.x += this.params.direction * 2;
                if (this.x <= 0 || this.x >= 184) {
                    this.params.direction *= -1;
                }
                break;
        }
        this.element.style.transform = `translate(${this.x}px, ${this.y}px)`;
        return this.y < 200 && this.y > -20 && this.x > -20 && this.x < 220;
    }
}

// Update the ENEMIES object to include attack patterns
const ENEMIES = {
    Froggit: {
        name: 'Froggit',
        sprite: 'Froggit.png',
        maxHP: 20,
        hp: 20,
        attack: 4,
        defense: 5,
        attacks: ['hop', 'fly'],
        mercy: false,
        description: '* Froggit hopped close!',
        checkText: "* FROGGIT - ATK 4 DEF 5\n* Life is difficult for this enemy.",
        actOptions: ['Check', 'Flirt'],
        flirtText: "* You flirt with Froggit.\n* It seems flattered...",
        attackPatterns: {
            hop: {
                duration: 5000,
                bulletSpawn: (time) => {
                    if (time % 60 === 0) {
                        return new Bullet(
                            Math.random() * 160, 
                            0,
                            'hop',
                            { 
                                speed: 2,
                                sprite: 'Fly.gif',
                                width: 16,  // Adjust size for the fly sprite
                                height: 16
                            }
                        );
                    }
                    return null;
                }
            },
            fly: {
                duration: 5000,
                bulletSpawn: (time) => {
                    if (time % 45 === 0) {
                        return new Bullet(
                            0,
                            Math.random() * 160,
                            'fly',
                            { 
                                speedX: 3,
                                time: 0,
                                sprite: 'Fly.gif',
                                width: 16,  // Adjust size for the fly sprite
                                height: 16
                            }
                        );
                    }
                    return null;
                }
            }
        }
    },
    Test1: {
        name: 'Test1',
        sprite: 'Test1.png', // Changed from 'Froggit.png' to 'Test1.png'
        maxHP: 30,
        hp: 30,
        attack: 6,
        defense: 4,
        attacks: ['spin', 'dance'],
        mercy: false,
        description: '* Test1 draws near!',
        checkText: "* TEST1 - ATK 6 DEF 4\n* Just a test enemy.",
        actOptions: ['Check'],
        attackPatterns: {
            spin: {
                duration: 5000,
                bulletSpawn: (time) => {
                    if (time % 30 === 0) {
                        return new Bullet(
                            100,
                            100,
                            'spin',
                            { angle: time * 0.1, radius: 50 }
                        );
                    }
                    return null;
                }
            },
            dance: {
                duration: 5000,
                bulletSpawn: (time) => {
                    if (time % 40 === 0) {
                        return new Bullet(
                            92,
                            0,
                            'dance',
                            { speed: 3, direction: 1 }
                        );
                    }
                    return null;
                }
            }
        }
    }
};

let currentEnemy = null;
let isInvincible = false; // New variable for invincibility
const INVINCIBILITY_DURATION = 1000; // 1 second of invincibility

const introSequences = [
    {
        text: "Long ago, two races ruled over Earth:\nHUMANS and MONSTERS.",
        duration: 4000,
        image: 'Intro1.png'
    },
    {
        text: "One day, war broke out\nbetween the two races.",
        duration: 4000,
        image: 'Intro2.png'  // Add Intro2.png as the image for the second sequence
    },
    {
        text: "After a long battle,\nthe humans were victorious.",
        duration: 4000
    },
    {
        text: "They sealed the monsters\nto the Underground with a magic spell.",
        duration: 4000
    },
    {
        text: "Many years later...",
        duration: 3000
    },
    {
        text: "MT. EBOTT\n201X",
        duration: 3000
    },
    {
        text: "Legends say that those who climb the mountain\nnever return.",
        duration: 4000
    },
    {
        text: "",  // Blank for final image
        duration: 4000
    }
];

let currentSequence = 0;

// New player-related variables
let walkAnimationFrame = 0;
let lastAnimationUpdate = 0;
const ANIMATION_FRAME_DURATION = 150; // Duration for each frame in milliseconds
const walkDownSprites = ['DownWalk1.png', 'Down.png', 'DownWalk3.png'];
let isMoving = false;

let menuOpen = false;
let selectedMenuOption = 0;
const menuOptions = ['ITEM', 'STAT', 'CELL'];

function createMenuInterface() {
    const menuInterface = document.createElement('div');
    menuInterface.className = 'menu-interface';
    
    menuOptions.forEach((option, index) => {
        const menuOption = document.createElement('div');
        menuOption.className = 'menu-option' + (index === 0 ? ' selected' : '');
        menuOption.textContent = option;
        menuInterface.appendChild(menuOption);
    });
    
    document.getElementById('gameWorld').appendChild(menuInterface);
}

function playIntroSequence() {
    const introSequence = document.getElementById('introSequence');
    const introImage = document.getElementById('introImage');
    const introText = document.getElementById('introText');
    const creditsSequence = document.getElementById('creditsSequence');
    const container = document.getElementById('mainContainer');
    
    container.style.display = 'none';
    
    // Add skip functionality with a named function so we can remove it
    function handleSkip(e) {
        if (e.key.toLowerCase() === 'z') {
            // Remove the event listener first
            window.removeEventListener('keydown', handleSkip);
            skipToCredits();
        }
    }
    
    // Add the event listener
    window.addEventListener('keydown', handleSkip);
    
    function skipToCredits() {
        introSequence.classList.add('hidden');
        showCredits();
    }
    
    function showNextSequence() {
        if (currentSequence >= introSequences.length) {
            window.removeEventListener('keydown', handleSkip);
            introSequence.classList.add('hidden');
            setTimeout(() => {
                showCredits();
            }, 100);
            return;
        }
        
        const introImage = document.getElementById('introImage');
        const introText = document.getElementById('introText');
        
        // Clear previous text
        introText.textContent = '';
        
        // Handle image
        if (introSequences[currentSequence].image) {
            introImage.style.backgroundImage = `url('${introSequences[currentSequence].image}')`;
            introImage.style.backgroundColor = 'transparent';
            introImage.style.display = 'block';
        } else {
            introImage.style.backgroundImage = 'none';
            introImage.style.backgroundColor = '#fff';
            introImage.style.display = 'block';
        }
        
        // Type out text character by character
        const text = introSequences[currentSequence].text;
        let charIndex = 0;
        
        function typeText() {
            if (charIndex < text.length) {
                introText.textContent += text[charIndex];
                charIndex++;
                setTimeout(typeText, 50); // Adjust typing speed here
            } else {
                // Move to next sequence after typing is complete and duration has passed
                setTimeout(() => {
                    currentSequence++;
                    showNextSequence();
                }, introSequences[currentSequence].duration - (text.length * 50));
            }
        }
        
        typeText();
    }
    
    function showCredits() {
        creditsSequence.classList.remove('hidden');
        setTimeout(() => {
            creditsSequence.classList.add('hidden');
            // Remove the credits element completely after the fade out
            setTimeout(() => {
                creditsSequence.remove(); // Completely remove the credits element
                container.style.display = 'block';
            }, 1000);
        }, 5000); // Show credits for 5 seconds
    }
    
    showNextSequence();
}

// Call playIntroSequence before any other initialization
window.addEventListener('load', () => {
    playIntroSequence();
    createLetterGrid();  // Move this here from the bottom of the file
});

const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
let currentName = '';
let isConfirmationMode = false;
let playerX = 290;
let playerY = 190;
let keys = {};
let currentDirection = 'down';

let playerHP = 20;
let playerMaxHP = 20;
let playerLV = 1;

// New combat variables
let inCombat = false;
let isAttacking = false;
let attackStartTime = 0;
let attackDamageMultiplier = 1;
let soulX = 92; // Center of box (200/2 - 16/2)
let soulY = 92;
const SOUL_SPEED = 2;

function createLetterGrid() {
    const grid = document.getElementById('letterGrid');
    grid.innerHTML = '';
    letters.forEach((letter, index) => {
        const letterElement = document.createElement('span');
        letterElement.className = 'letter shake';
        letterElement.style.setProperty('--delay', `-${index * 0.1}s`);
        letterElement.textContent = letter;
        letterElement.addEventListener('click', () => {
            if (!isConfirmationMode && currentName.length < 6) {
                currentName += letter;
                updateNameDisplay();
            }
        });
        grid.appendChild(letterElement);
    });
}

function updateNameDisplay() {
    const display = document.getElementById('selectedName');
    display.innerHTML = '';
    currentName.split('').forEach((letter, index) => {
        const letterSpan = document.createElement('span');
        letterSpan.className = 'letter' + (isConfirmationMode ? ' shake' : '');
        letterSpan.style.setProperty('--delay', `-${index * 0.1}s`);
        letterSpan.textContent = letter;
        display.appendChild(letterSpan);
    });
}

function preloadSprites() {
    const sprites = [
        'Down.png', 'Up.png', 'Left.png', 'Right.png',
        'DownWalk1.png', 'DownWalk3.png', 'Fly.gif'  // Added Fly.gif
    ];
    sprites.forEach(sprite => {
        const img = new Image();
        img.src = sprite;
    });
}

// Call preloadSprites immediately
preloadSprites();

function updatePlayerSprite(direction) {
    if (direction !== currentDirection) {
        const player = document.getElementById('player');
        if (direction === 'down') {
            // Reset walk animation when changing to down direction
            walkAnimationFrame = 0;
            lastAnimationUpdate = Date.now();
            player.style.backgroundImage = `url('${walkDownSprites[0]}')`;
        } else {
            const newSprite = direction.charAt(0).toUpperCase() + direction.slice(1) + '.png';
            requestAnimationFrame(() => {
                player.style.backgroundImage = `url('${newSprite}')`;
            });
        }
        currentDirection = direction;
    }
}

function showBattleText(text) {
    const battleText = document.querySelector('.battle-text');
    battleText.textContent = text;
    battleText.classList.remove('visible');
    
    // Force a reflow
    void battleText.offsetWidth;
    
    // Make text visible with transition
    battleText.classList.add('visible');
}

function updateStats() {
    const nameStats = document.querySelector('.name-stats');
    const hpBar = document.querySelector('.hp-bar');
    const hpNumbers = document.querySelector('.hp-numbers');
    
    nameStats.textContent = `${currentName}    LV ${playerLV}`;
    hpBar.style.width = `${(playerHP / playerMaxHP) * 100}%`;
    hpNumbers.textContent = `${playerHP} / ${playerMaxHP}`;
}

function startGame() {
    const gameWorld = document.getElementById('gameWorld');
    const nameInterface = document.getElementById('nameInterface');
    
    setTimeout(() => {
        nameInterface.classList.add('hidden');
        gameWorld.classList.add('visible');
        createMenuInterface(); // Add this line
        initializeGameControls();
    }, 2000);
}

function finalizeSelection() {
    const container = document.getElementById('mainContainer');
    const nameDisplay = document.getElementById('selectedName');
    const controls = document.getElementById('controls');
    
    controls.classList.add('hidden');
    nameDisplay.classList.add('final');
    container.classList.add('fade-white');
    startGame();
}

function toggleConfirmationMode() {
    isConfirmationMode = !isConfirmationMode;
    const nameTitle = document.getElementById('nameTitle');
    const quitBtn = document.getElementById('quitBtn');
    const doneBtn = document.getElementById('doneBtn');
    const letterGrid = document.getElementById('letterGrid');
    const nameDisplay = document.getElementById('selectedName');

    if (isConfirmationMode) {
        if (currentName.toUpperCase() === 'CHARA') {
            nameTitle.textContent = 'The true name.';
        } else {
            nameTitle.textContent = 'Is this name correct?';
        }
        quitBtn.textContent = 'No';
        doneBtn.textContent = 'Yes';
        letterGrid.classList.add('hidden');
        nameDisplay.classList.add('confirmed');
        updateNameDisplay();
    } else {
        nameTitle.textContent = 'Name the fallen human';
        quitBtn.textContent = 'Quit';
        doneBtn.textContent = 'Done';
        letterGrid.classList.remove('hidden');
        nameDisplay.classList.remove('confirmed');
        updateNameDisplay();
    }
}

function initializeGameControls() {
    let inBattle = false;
    let lastEncounterTime = 0;
    const encounterCooldown = 1000; // Minimum time between encounters
    let mercyOptionsVisible = false;
    let selectedMercyOption = 0; // 0 for SPARE, 1 for FLEE
    let actOptionsVisible = false; // New variable for ACT options
    let selectedActOption = 0; // Track selected ACT option
    let canSpareEnemy = false;

    window.addEventListener('keydown', e => {
        keys[e.key] = true;
        
        if (!inBattle) {
            if (e.key.toLowerCase() === 'c') {
                toggleMenu();
            }
            
            if (menuOpen) {
                handleMenuControls(e);
            }
        }
        
        if (inBattle && e.key.toLowerCase() === 'x') {
            // Only end battle if we're not showing mercy options
            if (!mercyOptionsVisible && !actOptionsVisible) {
                endBattle();
            }
        }
    });

    window.addEventListener('keyup', e => {
        keys[e.key] = false;
    });

    function toggleMenu() {
        menuOpen = !menuOpen;
        const menuInterface = document.querySelector('.menu-interface');
        
        if (menuOpen) {
            menuInterface.style.display = 'block';
            selectedMenuOption = 0;
            updateMenuSelection();
        } else {
            menuInterface.style.display = 'none';
        }
    }

    function handleMenuControls(e) {
        const prevSelection = selectedMenuOption;
        
        switch(e.key.toLowerCase()) {
            case 'arrowup':
                selectedMenuOption = (selectedMenuOption - 1 + menuOptions.length) % menuOptions.length;
                break;
            case 'arrowdown':
                selectedMenuOption = (selectedMenuOption + 1) % menuOptions.length;
                break;
            case 'x':
                toggleMenu();
                return;
            case 'z':
                handleMenuSelection();
                return;
        }
        
        if (prevSelection !== selectedMenuOption) {
            updateMenuSelection();
        }
    }

    function updateMenuSelection() {
        const options = document.querySelectorAll('.menu-option');
        options.forEach((option, index) => {
            option.classList.toggle('selected', index === selectedMenuOption);
        });
    }

    function handleMenuSelection() {
        const selectedOption = menuOptions[selectedMenuOption];
        switch(selectedOption) {
            case 'ITEM':
                console.log('Items menu selected');
                break;
            case 'STAT':
                console.log('Stats menu selected');
                break;
            case 'CELL':
                console.log('Cell menu selected');
                break;
        }
    }

    function checkForEncounter() {
        const now = Date.now();
        if (now - lastEncounterTime < encounterCooldown || inBattle) return false;
        
        // Reduced from 2% to 0.5% chance of encounter per movement
        if (Math.random() < 0.005 && (keys['ArrowUp'] || keys['ArrowDown'] || keys['ArrowLeft'] || keys['ArrowRight'])) {
            lastEncounterTime = now;
            // Freeze player movement
            const player = document.getElementById('player');
            player.style.transition = 'none';
            return true;
        }
        return false;
    }

    function showMercyOptions() {
        const spareText = canSpareEnemy ? "> SPARE [READY]" : "> SPARE [NOT READY]";
        const fleeText = "  FLEE";
        
        if (selectedMercyOption === 0) {
            showBattleText(`${spareText}\n${fleeText}`);
        } else {
            showBattleText(`  SPARE ${canSpareEnemy ? '[READY]' : '[NOT READY]'}\n> FLEE`);
        }
    }

    function showActOptions() {
        actOptionsVisible = true;
        selectedActOption = 0;
        
        // Display ACT options
        let actText = currentEnemy.actOptions.map((opt, i) => 
            `${i === selectedActOption ? '> ' : '  '}${opt}`
        ).join('\n');
        
        showBattleText(actText);
    }

    function startBattle() {
        inBattle = true;
        
        // Freeze player movement immediately
        const player = document.getElementById('player');
        player.style.transition = 'none';
        
        // Create and show surprise sprite positioned exactly at player position
        const surpriseSprite = document.createElement('div');
        surpriseSprite.className = 'surprise-sprite';
        surpriseSprite.style.transform = `translate(${playerX}px, ${playerY - 48}px)`; // Position directly above player
        document.getElementById('gameWorld').appendChild(surpriseSprite);
        
        // Force reflow
        void surpriseSprite.offsetWidth;
        surpriseSprite.classList.add('visible');
        
        // Wait a few seconds before battle transition
        setTimeout(() => {
            // Remove surprise sprite
            surpriseSprite.classList.remove('visible');
            setTimeout(() => surpriseSprite.remove(), 300);
            
            // Randomly select enemy type
            const enemyTypes = Object.keys(ENEMIES);
            const selectedType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            currentEnemy = {...ENEMIES[selectedType]}; // Clone enemy data

            const flash = document.querySelector('.battle-flash');
            const battleInterface = document.querySelector('.battle-interface');
            const battleTextBox = document.querySelector('.battle-text-box');
            const battleStats = document.querySelector('.battle-stats');
            
            // Create enemy sprite if it doesn't exist
            if (!document.querySelector('.enemy-sprite')) {
                const enemySprite = document.createElement('div');
                enemySprite.className = 'enemy-sprite';
                battleInterface.appendChild(enemySprite);
            }
            
            // Update enemy sprite
            const enemySprite = document.querySelector('.enemy-sprite');
            enemySprite.style.backgroundImage = `url('${currentEnemy.sprite}')`;
            enemySprite.style.display = 'block';
            
            flash.classList.add('active');
            player.classList.add('in-battle');
            
            setTimeout(() => {
                battleInterface.style.display = 'block';
                battleTextBox.style.display = 'block';
                battleStats.style.display = 'block';
                updateStats();
                showBattleText(currentEnemy.description);
                
                const options = document.querySelectorAll('.battle-option');
                options[0].classList.add('selected');
                
                window.addEventListener('keydown', handleBattleControls);
            }, 400);
            
        }, 2000); // 2 second delay before battle transition
    }

    function handleBattleControls(e) {
        if (!inBattle || inCombat) return;

        if (mercyOptionsVisible) {
            // Handle mercy menu controls
            switch (e.key.toLowerCase()) {
                case 'arrowleft':  
                    selectedMercyOption = 0;
                    showMercyOptions();
                    break;
                case 'arrowright':  
                    selectedMercyOption = 1;
                    showMercyOptions();
                    break;
                case 'x':
                    // Exit mercy menu
                    mercyOptionsVisible = false;
                    showBattleText('* A monster appears!');
                    break;
                case 'z':
                    // Handle mercy option selection
                    if (selectedMercyOption === 0) {
                        if (canSpareEnemy) {
                            showBattleText('* You spared the enemy!');
                            setTimeout(endBattle, 1000);
                        } else {
                            showBattleText('* Cannot spare yet...');
                        }
                    } else {
                        // Handle FLEE
                        if (Math.random() < 0.25) {
                            showBattleText('* Got away successfully!');
                            setTimeout(endBattle, 1000);
                        } else {
                            showBattleText('* Couldn\'t escape!');
                        }
                    }
                    break;
            }
            return;
        }

        if (actOptionsVisible) {
            switch (e.key.toLowerCase()) {
                case 'arrowleft':  
                    if (selectedActOption > 0) {
                        selectedActOption--;
                        let actText = currentEnemy.actOptions.map((opt, i) => 
                            `${i === selectedActOption ? '> ' : '  '}${opt}`
                        ).join('\n');
                        showBattleText(actText);
                    }
                    break;
                case 'arrowright':  
                    if (selectedActOption < currentEnemy.actOptions.length - 1) {
                        selectedActOption++;
                        let actText = currentEnemy.actOptions.map((opt, i) => 
                            `${i === selectedActOption ? '> ' : '  '}${opt}`
                        ).join('\n');
                        showBattleText(actText);
                    }
                    break;
                case 'x':
                    actOptionsVisible = false;
                    showBattleText('* ' + currentEnemy.description);
                    break;
                case 'z':
                    handleActOption(currentEnemy.actOptions[selectedActOption]);
                    break;
            }
            return;
        }

        const options = document.querySelectorAll('.battle-option');
        let currentIndex = Array.from(options).findIndex(option => 
            option.classList.contains('selected')
        );

        switch (e.key.toLowerCase()) {
            case 'arrowleft':
                options[currentIndex].classList.remove('selected');
                currentIndex = (currentIndex - 1 + options.length) % options.length;
                options[currentIndex].classList.add('selected');
                break;
            case 'arrowright':
                options[currentIndex].classList.remove('selected');
                currentIndex = (currentIndex + 1) % options.length;
                options[currentIndex].classList.add('selected');
                break;
            case 'z':
                const selectedOption = options[currentIndex].getAttribute('data-option');
                handleBattleOption(selectedOption);
                break;
        }
    }

    function handleBattleOption(option) {
        switch(option) {
            case 'FIGHT':
                showBattleText('* Press Z to strike!');
                setTimeout(() => {
                    startAttack();
                }, 1000);
                break;
            case 'ACT':
                if (!currentEnemy) return;
                showActOptions();
                break;
            case 'ITEM':
                showBattleText('* Your items...');
                break;
            case 'MERCY':
                mercyOptionsVisible = true;
                selectedMercyOption = 0;
                // If enemy can be spared, show transparency
                if (canSpareEnemy) {
                    const enemySprite = document.querySelector('.enemy-sprite');
                    if (enemySprite) enemySprite.classList.add('spared');
                }
                showMercyOptions();
                break;
        }
    }

    function handleActOption(action) {
        if (!currentEnemy) return;
        
        switch(action) {
            case 'Check':
                showBattleText(currentEnemy.checkText);
                break;
            case 'Flirt':
                if (currentEnemy.name === 'Froggit') {
                    showBattleText(currentEnemy.flirtText);
                    currentEnemy.mercy = true;
                    canSpareEnemy = true;
                    setTimeout(() => {
                        startCombat();
                    }, 2000);
                }
                break;
        }
        actOptionsVisible = false;
    }

    function startAttack() {
        if (isAttacking) return; // Prevent multiple attack states
        
        isAttacking = true;
        const battleTextBox = document.querySelector('.battle-text-box');
        const battleText = document.querySelector('.battle-text');
        
        // Create attack bar container if it doesn't exist
        if (!document.querySelector('.attack-bar-container')) {
            const container = document.createElement('div');
            container.className = 'attack-bar-container';
            container.innerHTML = `
                <div class="attack-target"></div>
                <div class="attack-bar"></div>
            `;
            battleTextBox.appendChild(container);
        }
        
        const container = document.querySelector('.attack-bar-container');
        const bar = document.querySelector('.attack-bar');
        
        // Reset and show attack bar
        container.style.display = 'block';
        bar.style.animation = 'none';
        void bar.offsetWidth; // Force reflow
        bar.style.animation = 'moveAttackBar 2s linear';
        
        attackStartTime = Date.now();
        
        // Remove any existing attack event listener before adding a new one
        window.removeEventListener('keydown', handleAttack);
        window.addEventListener('keydown', handleAttack);
    }

    function handleAttack(e) {
        if (!isAttacking || e.key.toLowerCase() !== 'z' || !currentEnemy) return;
        
        const container = document.querySelector('.attack-bar-container');
        const bar = document.querySelector('.attack-bar');
        
        if (!container || !bar) {
            console.error('Attack bar elements not found');
            return;
        }
        
        const barRect = bar.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        const centerX = containerRect.left + (containerRect.width / 2);
        
        const distance = Math.abs(barRect.left - centerX);
        const maxDistance = containerRect.width / 2;
        
        attackDamageMultiplier = Math.max(0, 1 - (distance / maxDistance));
        
        bar.style.animation = 'none';
        
        const damage = Math.round(attackDamageMultiplier * 20);
        currentEnemy.hp = Math.max(0, currentEnemy.hp - damage);
        
        const enemySprite = document.querySelector('.enemy-sprite');
        if (enemySprite) {
            enemySprite.style.setProperty('--shake-intensity', `${damage/2}px`);
            enemySprite.classList.remove('shake');
            void enemySprite.offsetWidth;
            enemySprite.classList.add('shake');
        }
        
        showBattleText(`* You dealt ${damage} damage to ${currentEnemy.name}!`);
        
        isAttacking = false;
        window.removeEventListener('keydown', handleAttack);
        
        setTimeout(() => {
            if (enemySprite) enemySprite.classList.remove('shake');
            if (container) container.style.display = 'none';
            if (currentEnemy && currentEnemy.hp <= 0) {
                // Add fade effect before showing defeat message
                if (enemySprite) {
                    enemySprite.classList.add('fading');
                    // Wait for fade animation to complete
                    setTimeout(() => {
                        showBattleText(`* ${currentEnemy.name} was defeated!`);
                        setTimeout(endBattle, 1000);
                    }, 1000);
                } else {
                    showBattleText(`* ${currentEnemy.name} was defeated!`);
                    setTimeout(endBattle, 1000);
                }
            } else {
                setTimeout(() => {
                    startCombat();
                }, 500);
            }
        }, 1000);
    }

    function startCombat() {
        if (!currentEnemy) return; // Add check for currentEnemy
        
        if (isAttacking) {
            window.removeEventListener('keydown', handleAttack);
            isAttacking = false;
            const container = document.querySelector('.attack-bar-container');
            if (container) container.style.display = 'none';
        }
        
        inCombat = true;
        const battleTextBox = document.querySelector('.battle-text-box');
        const battleBox = document.querySelector('.battle-box');
        const soul = document.querySelector('.player-soul');
        const enemySprite = document.querySelector('.enemy-sprite');
        
        // Add null checks for DOM elements
        if (!battleTextBox || !battleBox || !soul || !enemySprite) {
            console.error('Required battle elements not found');
            return;
        }
        
        enemySprite.style.top = '-450px';
        
        soulX = 92;
        soulY = 92;
        soul.style.transform = `translate(${soulX}px, ${soulY}px)`;
        
        battleTextBox.style.display = 'none';
        battleBox.style.display = 'block';
        
        // Add null check for attack patterns
        if (!currentEnemy.attacks || !currentEnemy.attacks.length) {
            console.error('No attack patterns found for enemy');
            return;
        }
        
        // Select random attack pattern
        const attackPattern = currentEnemy.attacks[Math.floor(Math.random() * currentEnemy.attacks.length)];
        
        // Add null check for attack pattern
        if (!currentEnemy.attackPatterns || !currentEnemy.attackPatterns[attackPattern]) {
            console.error('Invalid attack pattern');
            return;
        }
        
        const bullets = [];
        let timeElapsed = 0;
        
        function updateBullets() {
            if (!inCombat || !currentEnemy) return;
            
            // Add null check for attack pattern
            if (!currentEnemy.attackPatterns[attackPattern]) return;
            
            // Spawn new bullets
            const newBullet = currentEnemy.attackPatterns[attackPattern].bulletSpawn(timeElapsed);
            if (newBullet) {
                bullets.push(newBullet);
                battleBox.appendChild(newBullet.element);
            }
            
            // Update existing bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const isAlive = bullets[i].update();
                if (!isAlive) {
                    battleBox.removeChild(bullets[i].element);
                    bullets.splice(i, 1);
                }
            }
            
            // Check collision with soul
            const soulHitbox = {
                x: soulX + 4,
                y: soulY + 4,
                width: 8,
                height: 8
            };
            
            for (const bullet of bullets) {
                if (!isInvincible && checkCollision(soulHitbox, bullet)) {
                    takeDamage(3);
                    break; // Exit loop after taking damage once
                }
            }
            
            timeElapsed++;
            
            // End combat after duration
            if (timeElapsed >= currentEnemy.attackPatterns[attackPattern].duration / (1000/60)) {
                endCombatTurn();
                return;
            }
            
            requestAnimationFrame(updateBullets);
        }

        // Start the combat loops
        combatLoop();
        updateBullets();
    }

    function combatLoop() {
        if (!inCombat) return;

        const soul = document.querySelector('.player-soul');
        const speed = SOUL_SPEED;
        
        // Move soul based on arrow keys
        if (keys['ArrowUp']) {
            soulY = Math.max(0, soulY - speed);
        }
        if (keys['ArrowDown']) {
            soulY = Math.min(184, soulY + speed);
        }
        if (keys['ArrowLeft']) {
            soulX = Math.max(0, soulX - speed);
        }
        if (keys['ArrowRight']) {
            soulX = Math.min(184, soulX + speed);
        }

        // Update soul position
        soul.style.transform = `translate(${soulX}px, ${soulY}px)`;

        // Continue the combat loop
        requestAnimationFrame(combatLoop);
    }

    function checkCollision(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width &&
               rect1.x + rect1.width > rect2.x &&
               rect1.y < rect2.y + rect2.height &&
               rect1.y + rect1.height > rect2.y;
    }

    function takeDamage(amount) {
        if (isInvincible) return; // Don't take damage if invincible
        
        playerHP = Math.max(0, playerHP - amount);
        updateStats();
        
        // Make soul invincible and flash
        isInvincible = true;
        const soul = document.querySelector('.player-soul');
        soul.style.animation = 'flash-soul 0.2s infinite';
        
        setTimeout(() => {
            isInvincible = false;
            soul.style.animation = 'none';
        }, INVINCIBILITY_DURATION);
        
        if (playerHP <= 0) {
            // Implement game over sequence here
        }
    }

    function endCombatTurn() {
        const battleBox = document.querySelector('.battle-box');
        const battleTextBox = document.querySelector('.battle-text-box');
        
        // Remove all bullets
        const bullets = document.querySelectorAll('.bullet');
        bullets.forEach(bullet => bullet.remove());
        
        battleBox.style.display = 'none';
        battleTextBox.style.display = 'block';
        showBattleText('* ' + currentEnemy.name + ' awaits your move.');
        
        inCombat = false;
    }

    function gameLoop() {
        if (!inBattle && !menuOpen) {  // Add !menuOpen check
            const speed = 3;
            const containerHeight = document.getElementById('mainContainer').clientHeight;
            const containerWidth = document.getElementById('mainContainer').clientWidth;
            const playerSize = 32;
            
            // Track if player is moving this frame
            let moving = false;

            if (keys['ArrowUp']) {
                playerY = Math.max(0, playerY - speed);
                updatePlayerSprite('up');
                moving = true;
            }
            if (keys['ArrowDown']) {
                playerY = Math.min(containerHeight - 48, playerY + speed);
                updatePlayerSprite('down');
                moving = true;
            }
            if (keys['ArrowLeft']) {
                playerX = Math.max(0, playerX - speed);
                updatePlayerSprite('left');
                moving = true;
            }
            if (keys['ArrowRight']) {
                playerX = Math.min(containerWidth - playerSize, playerX + speed);
                updatePlayerSprite('right');
                moving = true;
            }

            // Update animation state
            if (moving !== isMoving) {
                isMoving = moving;
                if (!isMoving) {
                    // Reset to standing sprite when stopped
                    const player = document.getElementById('player');
                    if (currentDirection === 'down') {
                        player.style.backgroundImage = `url('Down.png')`;
                    }
                    walkAnimationFrame = 0;
                }
            }

            // Handle walk animation
            if (isMoving && currentDirection === 'down') {
                const now = Date.now();
                if (now - lastAnimationUpdate > ANIMATION_FRAME_DURATION) {
                    walkAnimationFrame = (walkAnimationFrame + 1) % walkDownSprites.length;
                    const player = document.getElementById('player');
                    player.style.backgroundImage = `url('${walkDownSprites[walkAnimationFrame]}')`;
                    lastAnimationUpdate = now;
                }
            }

            const player = document.getElementById('player');
            player.style.transform = `translate(${playerX}px, ${playerY}px)`;

            if (checkForEncounter()) {
                startBattle();
            }
        }
        requestAnimationFrame(gameLoop);
    }

    gameLoop();

    function endBattle() {
        inBattle = false;
        inCombat = false;
        isAttacking = false;
        
        const battleInterface = document.querySelector('.battle-interface');
        const battleTextBox = document.querySelector('.battle-text-box');
        const battleStats = document.querySelector('.battle-stats');
        const battleBox = document.querySelector('.battle-box');
        const player = document.getElementById('player');
        const enemySprite = document.querySelector('.enemy-sprite');
        const attackBarContainer = document.querySelector('.attack-bar-container');

        battleInterface.style.display = 'none';
        battleTextBox.style.display = 'none';
        battleStats.style.display = 'none';
        battleBox.style.display = 'none';
        if (attackBarContainer) {
            attackBarContainer.style.display = 'none';
        }

        if (enemySprite) {
            // Remove any fade-related classes
            enemySprite.classList.remove('fading', 'spared');
            enemySprite.style.display = 'none';
            enemySprite.style.top = '-400px';
        }

        const bullets = document.querySelectorAll('.bullet');
        bullets.forEach(bullet => bullet.remove());

        player.classList.remove('in-battle');

        window.removeEventListener('keydown', handleBattleControls);

        currentEnemy = null;
        mercyOptionsVisible = false;
        selectedMercyOption = 0;
        actOptionsVisible = false;
        selectedActOption = 0;
        canSpareEnemy = false; // Reset spare state
    }
}

document.getElementById('doneBtn').addEventListener('click', () => {
    if (!isConfirmationMode && currentName.length > 0) {
        toggleConfirmationMode();
    } else if (isConfirmationMode) {
        finalizeSelection();
    }
});

document.getElementById('quitBtn').addEventListener('click', () => {
    if (isConfirmationMode) {
        toggleConfirmationMode();
    } else {
        currentName = '';
        updateNameDisplay();
    }
});

createLetterGrid();
</script>
</body></html>
